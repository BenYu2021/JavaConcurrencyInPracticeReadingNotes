# 第4章 对象的组合
---
## 4.1 设计线程安全的类
* 通过使用封装技术，可以使得在不对整个程序进行分析的情况下就可以判断一个类是否是线程安全。
* 同步策略定义了如何在不违背对象不变条件或后验条件的情况下对其状态的访问操作进行协同。

>在设计线程安全类的过程中，需要包含以下三个基本要素：  
>* 找出构成对象状态的所有变量。
>* 找出约束状态变量的不变性条件。
>* 建立状态的并发访问策略。

### 4.1.1 收集同步策略
* 对象的状态空间
>如果不了解对象的不变性条件，那么就不能确保线程安全性。
>要满足在状态变量的有效值或状态转换上的各种约束条件，
>就需要借助于原子性与封装性。
### 4.1.2 依赖状态的操作
* 依赖状态的操作：某个操作中包含有基于状态的先验条件。

### 4.1.3 状态的所有权
* 所有权

### 4.2 实例封闭
>将数据封装在对象内部，可以将数据的访问控制在对象的方法上，从而更容易确保线程在访问数据时总能持有正确的锁。

>封闭机制更易于构造线程安全的类，因为当封闭类的状态时，在分析类的线程安全性时就无须检查整个程序。

### 4.2.1 Java监视器模式
* 遵循Java监视器模式的对象会把对象的所有可变状态封装起来，并由对象字节的内置锁保护起来。

### 4.2.2 示例：车辆追踪

## 4.3 线程安全性委托
### 4.3.1 示例：基于委托的车辆追踪器
### 4.3.2 独立的状态变量 
* VisualComponent.java
### 4.3.3 当委托失效时
* NumberRange.java
>如果一个类是由多个独立且线程安全的状态变量组成，并且所有的操作中都不包含无效数据转换，那么可以将线程安全性委托给底层的状态变量。
### 4.3.4 发布底层的状态变量
>如果一个状态变量是线程安全的，并且没有任何不变性条件来约束它的值，在变量的操作上也不存在任何不允许的状态转移，那么就可以安全地发布这个变量。

### 4.3.5 示例：发布状态的车辆追踪器

## 4.4 在现有的线程安全类中添加功能
* 添加一个新的原子操作：
    1. 修改原始类。
    2. 扩展这个类。  
        [BetterVector.java](<http://xxx.com>)
    3. 扩展这个类的功能，将扩展代码放入一个“辅助类中”。  
        [ListHelpers.java](<http://xxx.com>)
    4. 组合
### 4.4.1 客户端加锁机制
### 4.4.2 组合

## 4.5 将同步策略文档化


