# 第3章 对象的共享
---
* 临界区（Critical Section）
* 内存可见性（Memory Visibility）
## 3.1 可见性
* 重排序（Reordering）
>在没有同步的情况下，编译器、处理器以及运行时等都可能对操作的执行顺序进行一些意想不到的调整。
>在缺乏足够同步的多线程程序中，要想对内存操作的执行顺序进行判断，几乎无法得到正确的结论。

    只要数据在多个线程之间共享，就使用正确的同步。
    
### 3.1.1 失效数据
### 3.1.2 非原子的64位操作
* 最低安全性：
### 3.1.3 加锁与可见性
>加锁的含义不仅仅局限于互斥行为，还包括内存可见性。为了确保所有线程都能看到共享变量的最新值，所有执行读操作或者写操作的线程都必须在同一个锁上同步。

### 3.3.4 volatile变量
>仅当volatile变量能简化代码实现以及对同步策略验证时，才应该使用它们。
>如果在验证正确性时需要对可见性进行复杂判断，那么就不要使用volatile变量。  
>&emsp; volatile变量正确的使用方式包括：  
>&emsp;&emsp; 确保它们自身状态的可见性，  
>&emsp;&emsp; 确保它们所引用对象的可见性，  
>&emsp;&emsp; 以及标识一些重要的程序生命周期事件的发生（例如，初始化和关闭）。

>加锁机制既可以确保可见性又可以确保原子性，而volatile变量只能确保可见性。

---
当且仅当满足以下所有条件时，才应使用volatile变量：
* 当变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更变量的值。
* 该变量不与其他状态变量一起纳入不变性条件。
* 在访问变量时不需要加锁。
---
## 3.2 发布与溢出
* 发布一个对象：使对象能够在当前作用域之外的代码中使用。
* 逸出：某个不该发布的对象发布时。
* 发布对象的方式
    1. 将对象的引用保存到一个公有的静态变量中。  
    2. 当发布某个对象时，间接地发布其他对象。
    3. 当发布一个对象时，在该对象非私有域中引用的所有对象同样会被发布。
    4. 发布一个内部类的实例。
#### 安全的对象构造过程
>不要在构造过程中使用this引用逸出。

## 3.3 线程封闭
* 线程封闭：仅在单线程内访问数据。
### 3.3.1 Ad-hoc线程封闭
* Ad-hoc线程封闭：维护线程封闭的职责完全由程序实现来承担。
### 3.3.2 栈封闭
* 栈封闭：只能通过局部变量才能访问对象。

### 3.3.3 ThreadLocal类

## 3.4 不变性
* 不可变对象：被创建后其状态就不能被修改的对象。
>不可变对象一定是线程安全的。

>当满足以下条件时，对象才是不可变的:
>* 对象创建以后其状态就不能修改。
>* 对象所有域都是final类型。
>* 对象是正确创建的（在对象创建期间，this引用没有逸出）。

### 3.4.1 final域
>正如“除非需要更高的可见性，否则应将所有的域都声明为私有域”是一个良好的编程习惯，
>“除非需要某个域是可变的，否则应将其声明为final域”也是一个良好的编程习惯。
### 3.4.2 示例：使用volatile类型来发布不可变对象
    每当需要对一组相关数据以原子方式执行某个操作时，就可以考虑创建一个不可变的类来包含这些数据。
## 3.5 安全发布
### 3.5.1 不正确的发布：正确的对象被破坏
### 3.5.2 不可变对象与初始化安全性
>任何线程都可以在不需要额外同步的情况下安全地访问不可变对象，即使在发布这些对象时没有使用同步。
### 3.5.3 安全发布的常用模式
>要安全发布一个对象，对象的引用以及对象的状态必须同时对其他线程可见。一个正确都在的对象可以通过以下方式安全地发布：  
>* 在静态初始化函数中初始化一个对象引用。
>* 将对象的引用保存到volatile类型域或者AtomicReference对象中。
>* 将对象的引用保存到某个正确构造对象的final类型域中。
>* 将对象的引用保存到一个由锁保护的域中。
### 3.5.4 事实不可变对象
* 事实不可变对象：如果对象从技术上看是不可变的，但其状态在发布后不会再改变，那么表这种对象称为“事实不可变对象”。

>在没有额外同步的情况下，任何线程都可以使用被安全发布的事实不可变对象。

### 3.5.5 可变对象
>对象的发布需求取决于它的可变性：
>* 不可变对象可以通过任意机制来发布。
>* 事实不可变对象必须通过安全的方式来发布。
>* 可变对象必须通过安全方式来发布，并且必须是线程安全的或者由某个锁保护起来。
### 3.5.6 安全地共享对象

    当发布一个对象时，必须明确地说明对象的访问方式。
    
>在并发程序中使用和共享对象时，可以使用一些实用的策略，包括：  
>线程封闭。  
>只读共享。  
>线程安全共享。  
>保护对象。


