# 第3章 对象的共享
---
* 临界区（Critical Section）
* 内存可见性（Memory Visibility）
## 3.1 可见性
* 重排序（Reordering）
> 在没有同步的情况下，编译器、处理器以及运行时等都可能对操作的执行顺序进行一些意想不到的调整。
> 在缺乏足够同步的多线程程序中，要想对内存操作的执行顺序进行判断，几乎无法得到正确的结论。

    只要数据在多个线程之间共享，就使用正确的同步。
    
### 3.1.1 失效数据
### 3.1.2 非原子的64位操作
* 最低安全性：
### 3.1.3 加锁与可见性
> 加锁的含义不仅仅局限于互斥行为，还包括内存可见性。为了确保所有线程都能看到共享变量的最新值，所有执行读操作或者写操作的线程都必须在同一个锁上同步。

### 3.3.4 volatile变量
> 仅当volatile变量能简化代码实现以及对同步策略验证时，才应该使用它们。
> 如果在验证正确性时需要对可见性进行复杂判断，那么就不要使用volatile变量。  
> &emsp; volatile变量正确的使用方式包括：  
> &emsp;&emsp; 确保它们自身状态的可见性，  
> &emsp;&emsp; 确保它们所引用对象的可见性，  
> &emsp;&emsp; 以及标识一些重要的程序生命周期事件的发生（例如，初始化和关闭）。

> 加锁机制既可以确保可见性又可以确保原子性，而volatile变量只能确保可见性。

---
当且仅当满足以下所有条件时，才应使用volatile变量：
* 当变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更变量的值。
* 该变量不与其他状态变量一起纳入不变性条件。
* 在访问变量时不需要加锁。
---
## 3.2 发布与溢出
* 发布一个对象：使对象能够在当前作用域之外的代码中使用。
* 逸出：某个不该发布的对象发布时。
* 发布对象的方式
    1. 将对象的引用保存到一个公有的静态变量中。  
    2. 当发布某个对象时，间接地发布其他对象。
    3. 当发布一个对象时，在该对象非私有域中引用的所有对象同样会被发布。
    4. 发布一个内部类的实例。
    
## 3.3 线程封闭
## 3.4 不变性
## 3.5 安全发布

