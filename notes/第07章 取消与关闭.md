# 第7章 取消与关闭
* Java没有提供任何机制来安全地终止线程。但它提供了中断，这是一种协作机制，能够使一个线程终止另一个线程。 

## 7.1 任务取消

### 7.1.1 中断
>在Java的API或语言规范中，并没有将中断与任何取消语义关联起来，但实际上，如果在取消之外的其他操作中使用中断，
>那么都是不合适的，并且很难支撑器更大的应用。

* Thread中包含了中断线程和查询线程中断状态的方法。  
    interrupt方法能中断目标线程，isInterrupt方法能返回目标线程的中断状态。  
    静态的interrupted方法将清除当前线程的中断状态，并返回它之前的值。
    
>调用interrupt并不意味着立即停止目标线程正在进行的工作，而只是传递了请求中断的消息。

> 通常，中断是实现取消的最合理的方式。

### 7.1.2 中断策略
* 中断策略规定线程如何解释某个中断请求：当发现中断请求时，应该做哪些工作，
    哪些工作单元对于中断来说是原子操作，以及以多快的速度响应中断。
>由于每个线程拥有各自的中断策略，因此除非你知道中断对该线程的含义，否则就不应该中断这个线程。
### 7.1.3 响应中断
* 两种实用策略可以处理中断：  
    * 传递异常（可能在实现某个特定与任务的清除操作之后），从而使你的方法也可称为可中断的阻塞方法。  
    * 恢复中断状态，从而使调用栈中的上层daunt能够对其进行处理。

>只有实现了线程中断策略的代码才可以屏蔽中断请求。在常规的任务和代码库中都不应该屏蔽中断请求。



### 7.1.4 示例；计时运行
### 7.1.5 通过Future来实现取消

程序清单7-10 通过Future来取消任务   
[TimedRun.java](<https://github.com/BenYu2021/JavaConcurrencyInPracticeReadingNotes/blob/main/src/main/java/ch07/SingleThreadWebServer.java>)  

> 当Future抛出InterruptException或者TimeoutException时，如果你知道不在需要结果，那么就可以调用Future.cancel来取消任务。


### 7.1.6 处理不可中断的阻塞
程序清单7-11 通过改写interrupt方法将非标准的取消操作封装在Thread中 
[ReaderThread.java](<https://github.com/BenYu2021/JavaConcurrencyInPracticeReadingNotes/blob/main/src/main/java/ch07/ReaderThread.java>)  
### 7.1.7 采用newTaskFor来封装非表中的取消

## 7.2 停止基于线程的服务
>对于持有线程的服务，只要服务的存在时间大于创建线程方法的存在时间，那么就应该提供生命周期方法。


## 7.3 处理非正常的线程终止
## 7.4 JVM关闭

程序清单7-1 串行的Web服务器  
[SingleThreadWebServer.java](<https://github.com/BenYu2021/JavaConcurrencyInPracticeReadingNotes/blob/main/src/main/java/ch07/TimedRun.java>)  

