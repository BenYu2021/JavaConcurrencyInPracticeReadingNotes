# 第5章 基础构建模块

## 5.1 同步容器类
*   同步工具类包括Vector和HashTable。  
    这些同步的封装器类是由Collections.synchronizedXxx等工厂方法创建的。  
    这些类的实现线程安全的方式：将它们的状态封装起来，并对每个公有方法都进行同步，使得每次只有一个线程能访问容器的状态。
### 5.1.1 同步容器类的问题
### 5.1.2 迭代器与ConcurrentModificationException
### 5.1.3 隐藏迭代器
>正如封装对象的状态有助于维持不变性条件一样，封装对象的同步机制同样有助于确保实施同步策略。

* 容器的hashCode和equals等方法也会间接地执行迭代操作。
## 5.2 并发容器
>通过并发容器来代替同步容器，可以极大地提高伸缩性并降低风险。 
### 5.2.1 ConcurrentHashMap
* ConcurrentHashMap使用了一种粒度更细的加锁机制来实现更大程度的共享，分段锁。
### 5.2.2 额外的原子Map操作
### 5.2.3 CopyOnWriteArrayList

## 5.3 用阻塞队列和生产者-消费者模式
* 阻塞队列提供了可阻塞的put和take方法，以及支持定时的offer和poll方法。
* 一种常见的生产者-消费者模式是线程池和工作队列。
>在构建高可靠的应用程序时，有界队列是一种强大的资源管理工具：它们能抑制并防止产生过多工作项，使应用程序负荷过载的情况下变得更加健壮。
### 5.3.1 示例：桌面搜索
[ProducerConsumer.java](<https://github.com/BenYu2021/JavaConcurrencyInPracticeReadingNotes/blob/main/src/main/java/ch05/ProducerConsumer.java>)
### 5.3.2 串行线程封闭
* 线程封闭对象只能由单个线程拥有，但可通过安全地发布该对象来“转移”所有权。
在转移所有权后，也只有另一个线程能获得这个对象的访问权限，并且发布对象的线程不会再访问它。
* 对象池利用了串行线程封闭。
### 5.3.3 双端队列与工作密取
*  工作密取：每个消费者都有各自的双端队列。
消费者完成自己的双端队列中的全部任务后，可以从其他消费者双端队列中秘密地获取工作。
* 密取工作模式比传统的生产者-消费者模式具有更高的可伸缩性，因为工作者线程不会在单个共享的任务队列上发生竞争。
* 工作密取非常适用于既是消费者也是生产者问题。 
## 5.4 阻塞方法与中断方法
* 线程阻塞原因：等待I/O操作结束、等待获得一个锁、等待从Thread.sleep方法中醒来，或是等待另一个线程计算结果。
* 线程阻塞状态；BLOCKED、WAITING、TIMED_WAITING
* 处理对中断的响应：  
    1. 传递InterruptException  
    2. 恢复中断：Thread.currentThread().interrupt()
    

## 5.5 同步工具类
### 5.5.1 闭锁
[TestHarness.java](<https://github.com/BenYu2021/JavaConcurrencyInPracticeReadingNotes/blob/main/src/main/java/ch05/TestHarness.java>)

* 延迟线程的进度直到达到终止状态。
* CountDownLatch是一种灵活的闭锁实，它可以使一个或多个线程等待一组事件发生。
* 闭锁状态包括一个计数器，该计数器初始化为一个正数，表示需要等待的事件数量。
countDown方法递减计数器，表示有一个事情已经发生，
await方法等待计数器达到0，表示所有需要等待的事件都已经发生。
如果计数器的值非零，那么await会一直阻塞直到计数器为0或者等待中的线程中断，或者等待超时。


### 5.5.2 FutureTask
[Preloader.java](<https://github.com/BenYu2021/JavaConcurrencyInPracticeReadingNotes/blob/main/src/main/java/ch05/Preloader.java>)
* FutureTask也可以用作闭锁。
* FutureTask实现了future语义，表示一种抽象的可生成结果的计算
* FutureTask表示计算通过Callable来实现的，相当于一种可生成结果的Runnable，并且有以下三种状态：  
    等待状态  
    正在运行状态  
    运行完成
### 5.5.3 信号量
[BoundedHashSet.java](<https://github.com/BenYu2021/JavaConcurrencyInPracticeReadingNotes/blob/main/src/main/java/ch05/BoundedHashSet.java>)
* 计数器信号量用来控制某个特定资源的操作数量，或者同时执行某个指定操作的数量。
* 计数器信号量还可以用来实现资源池，对容器施加边界。
* Semaphore中管理着一组虚拟许可，
* 计算信号量的一种简化形式是二值信号量，即初始值为1的信号量。
二值信号量可以作为互斥体，并具备不可重入的加锁语义：谁拥有了这个唯一的许可，谁就拥有了互斥锁。
* acquire方法获取许可，release方法释放许可。

### 5.5.4 栅栏（暂时没看懂）
[CellularAutomata.java](<https://github.com/BenYu2021/JavaConcurrencyInPracticeReadingNotes/blob/main/src/main/java/ch05/CellularAutomata.java>)
* 闭锁是一次性对象，一旦进入终止状态就不能被重置。
* 栅栏类似于闭锁，它能阻塞一组线程直到某个时间发生。
* 栅栏与闭锁的关键区别：闭锁用于等待事件，而栅栏用于等待其他线程。
* 另一种形式的栅栏是Exchanger，它是两方栅栏，各方在栅栏位置上交换数据。

## 5.6 构建高效且可伸缩的结果缓存


# 第一部分结
>* 可变状态是至关重要的。  
>   所有的并发问都可以归结为如何协调并发状态的访问。可变状态越少，就越容易确保线程安全性。
>* 尽量将域声明为final类型，除非需要它们是可变的。
>* 不可变对象一定是线程安全的。  
>   不可变对象能极大地降低并发编程的复杂性。它们更为简单且安全，可以任意共享而无须使用加锁或保护性复制等机制。
>* 封装有助于管理复杂性。  
>   在编写线程安全程序时，虽然可以将所有数据都保存在全局变量中，但为什么要这样做？
>将数据封装在对象中，更易于维持不变性条件：将同步机制封装在对象中，更易于遵循同步策略。
>* 用锁来保护每个可变变量。
>* 当保护同一个不变性条件中所有的变量时，要使用同一个锁。
>* 在执行复合操作期间，要持有锁。
>* 如果多个线程访问同一个可变变量时没有同步机制，那么程序将会出现问题。
>* 不要故作聪明地推断出不需要使用同步，
>* 在设计过程中考虑线程安全，或者在文档中明确地指出它是不是线程安全的。
> * 将同步策略文档化。