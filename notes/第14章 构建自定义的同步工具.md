# 第14章 构建自定义的同步工具
## 14.1 状态依赖的管理
### 14.1.1 示例：将前提条件的失败传递给调用者
* 访问缓存时使用“先检查再运行”的逻辑策略。

程序清单14-3 当不满足条件时，有界缓存不会执行相应操作  
[GrumpyBoundedBuffer.java](../src/main/java/ch14/GrumpyBoundedBuffer.java)  

### 14.1.2 实例：通过轮询与休眠来实现简单的阻塞
* 如果缓存为空，那么take将休眠并直到另一个线程的在缓存中放入一些数据；  
    如果缓存已满，那么put将休眠并直到另一个线程从缓存中移除一些数据。
    
程序清单14-5 使用简单阻塞实现有界缓存  
[SleepyBoundedBuffer.java](../src/main/java/ch14/SleepyBoundedBuffer.java)  

### 14.1.3 条件队列

程序清单14-6 使用条件队列实现有界缓存  
[BoundedBuffer.java](../src/main/java/ch14/BoundedBuffer.java)  

## 14.2 使用条件队列
### 14.2.1 条件谓词
* 谓词，用来代替或者展示其客体性质、特征或者客体之间关系的词项。  
    在计算机语言的环境下，谓词是指条件表达式的求值返回真或假的过程。

* 条件谓词时使某个操作称为状态依赖操作的前提条件。
* 条件谓词是由类中各个状态变量构成的表达式。

>将条件队列相关联的条件谓词以及在这些条件谓词上等待的操作都写入文档。

* 在条件等待中存在一种重要的三元关系：加锁、wait方法和一个条件谓词。

>每一次wait调用都会隐式地与特定的条件谓词关联起来。当调用某个特定条件谓词的wait时，调用者必须已经持有与条件队列相关的锁，
>并且这个锁必须保护构成谓词的状态变量。

### 14.2.2 过早唤醒
>当使用条件等待时（例如Object.wait或者Condition.await）：
>* 通常都有一个条件谓词--包括一些对象状态的测试，线程执行前必须首先通过这些测试。
>* 在调用wait方法之前测试条件谓词，并且从wait中返回时再次进行测试。
>* 在一个循环中使用wait。
>* 确保使用与条件队列相关的锁来保护构成条件谓词的各个状态变量。
>* 当调用wait、notify或者notifyAll等方法时，一定要持有与条件队列相关的锁。
>* 在检查条件谓词之后以及开始执行相应的操作之前，不要释放锁。

### 14.2.3 丢失的信号
* 丢失的信号：线程必须等待一个已经为真的条件，但开始等待之前没有检查条件谓词。

### 14.2.4 通知
>每当在等待一个条件时，一定要确保在条件谓词变为真时通过某种方式发出通知。

>使用notify而不是notifyAll需满足的情况：
>* 所有等待线程的类型都相同。只有一个条件谓词与条件队列相关，并且每个线程在从wait返回后将执行相同的操作。
>* 单进单出。在条件变量上的每次通知，最多只能唤醒一个线程来执行。

### 14.2.5 示例：阀门类
### 14.2.6 子类安全问题
### 14.2.7 封装条件队列
### 14.2.8 入口协议和出口协议
* 入口协议就是该操作的谓词，
出口协议则包括，检查被该操作修改的所有状态变量，并确认它们是否使某个其他的条件谓词变为真，
如果是，则通知相关的条件队列。

## 14.3 显示Condition对象
## 14.4 Synchronizer剖析
14-12 使用Lock来实现信号量  
[SemaphoreOnLock.java](../src/main/java/ch14/SemaphoreOnLock.java)  

## 14.5 AbstractQueueSynchronizer
```java  
    boolean acquire() throws InterruptedException {
        while(当前状态不允许获取操作){
            if(需要阻塞获取请求){
                如果当前线程不在队列中，则将其插入队列
                阻塞当前线程    
            }else {
                返回失败
            }
        }
        可能更新同步器状态
        如果线程位于队列中，则将其移出队列
        返回成功
    } 

    void release(){
        更新同步器的状态
        if(新的状态允许某个被阻塞的线程获取成功){
            解除队列中一个或多个线程的阻塞状态
        }
    }
```
### 一个简单的闭锁
14-14 使用AbstractQueuedSynchronizer实现二元闭锁  
[OneShotLatch.java](../src/main/java/ch14/OneShotLatch.java)  
  
## 14.6 java.util.concurrent同步器类AQS
### 14.6.1 ReentrantLock
### 14.6.2 Semaphore和CountDownLatch
### 14.6.3 FutureTask
### 14.6.3 ReentrantReadWriteLock


